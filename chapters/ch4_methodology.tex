\chapter{METHODOLOGY}

\section{Proposed System}

\subsection{System Architecture Overview}

Our FIRMAI system employs modular microservices-inspired architecture with three primary subsystems operating in coordination. The layered three-tier architectural pattern separates concerns enabling independent development and scaling. Tier 1 Presentation Layer provides web dashboard with interactive visualization, REST API with JSON format supporting JWT authentication and versioned endpoints, and command-line interface supporting scripting with comprehensive help. Tier 2 Business Logic Layer implements firmware analysis orchestrator managing emulation lifecycle, network scanning coordinator controlling operations across address spaces, malware classification pipeline processing traffic through ML models, and integration engine correlating findings across subsystems generating unified reports. Tier 3 Data Layer uses PostgreSQL for firmware metadata with structured schema, MongoDB for semi-structured scan results and malware events, Redis for job queuing and caching, and object storage like MinIO/S3 for firmware images and model weights.

\subsection{Firmware Emulation Subsystem Design}

The firmware emulation subsystem automatically extracts, emulates, and analyzes IoT firmware with minimal intervention. Firmware ingestion service handles image upload accepting files via web or file path, validates integrity, extracts metadata, assigns unique identifiers, stores in object storage, and creates database records. Extraction engine executes binwalk identifying embedded filesystems, recursively extracts nested archives, identifies compressed formats, locates kernel images, determines processor architecture, and generates filesystem tree representation. Emulation orchestrator selects appropriate QEMU emulator based on architecture, configures virtual hardware, selects matching kernel, sets up virtual networking, applies arbitration techniques, launches QEMU, monitors boot process, and detects failures applying interventions. Arbitration engine implements boot arbitration modifying kernel command-line parameters and injecting boot scripts, network arbitration creating interfaces with expected names and forcing configurations, NVRAM arbitration emulating storage as persistent files, kernel arbitration maintaining pre-compiled kernel library, and environment arbitration creating device nodes and establishing expected paths. Vulnerability scanner enumerates exposed services, fingerprints versions, queries vulnerability databases, executes exploit modules, performs fuzzing, and documents successful exploits. Technology stack uses Python 3.10 for orchestration, binwalk 2.3+ for extraction, QEMU 5.2+ for emulation, PostgreSQL 14 for metadata, and Docker for containerized isolation.

\subsection{Network Scanning Subsystem Design}

The network scanning subsystem discovers IoT devices, identifies characteristics, and maps network topologies efficiently. Scan controller manages operations by validating CIDR input, generating IP address lists, distributing workload across worker threads, aggregating parallel scan results, handling timeouts and retries, and storing results in MongoDB. ARP scanner implements Layer 2 discovery constructing ARP request packets using Scapy, sending broadcast requests, capturing responses, extracting IP/MAC pairs, recording timestamps, and handling rate limiting. TCP scanner performs Layer 4 scanning implementing SYN scanning for speed, testing configurable port ranges, handling timeouts appropriately, identifying port states, performing banner grabbing, and recording version information. Device identifier determines types and vendors by extracting OUI from MAC addresses, querying vendor databases updated from IEEE, analyzing port patterns against device signatures, parsing service banners, applying heuristic rules, and assigning confidence scores. Result aggregator combines findings correlating ARP and TCP results by IP, merging vendor information with details, generating device inventory, calculating topology relationships, and exporting in multiple formats. Technology stack uses Python 3.10, Scapy 2.5+ for packets, python-nmap for enhanced scanning, mac-vendor-lookup for identification, MongoDB 6.0 for storage, and concurrent.futures for multi-threading.

\subsection{Malware Classification Subsystem Design}

The malware classification subsystem uses deep learning to identify and categorize IoT malware with high accuracy. Traffic capture module captures network traffic interfacing with libpcap or pyshark, supporting configurable BPF filters, implementing circular buffers for continuous capture, providing start/stop controls, and exporting PCAP format. Preprocessing pipeline extracts features including packet size statistics, protocol distributions, port frequencies, inter-arrival times, TCP flags, and payload byte frequency, then normalizes using standardization for normal distributions and min-max scaling for skewed features, encodes categorical variables using one-hot or label encoding, balances classes using SMOTE or undersampling, and splits into train/validation/test sets ensuring balance. CNN model architecture includes input layer accepting preprocessed features, feature learning layers with Dense 512/256/128/64 neurons using ReLU activation with batch normalization and dropout (40\%/40\%/30\%), and output layer with softmax activation producing class probabilities. Training configuration uses Adam optimizer with 0.001 learning rate, categorical cross-entropy loss, batch size 64, 50 epochs with early stopping patience 10, and 20\% validation split. Inference engine loads trained weights on startup, accepts preprocessed features, performs batch inference, applies softmax, returns predictions with confidence scores, and logs classifications. Model serving API provides REST endpoint accepting JSON traffic features with asynchronous processing for high throughput. Technology stack uses TensorFlow 2.12 with Keras, NumPy 1.24 and Pandas 2.0, Scikit-learn 1.2, FastAPI for serving, and CUDA 11.8 + cuDNN 8.6 for GPU acceleration.

\subsection{System Integration Architecture}

The integration layer unifies three subsystems into cohesive platform. API gateway provides single entry point routing requests to appropriate subsystems, implements authentication and authorization, enforces rate limiting, aggregates responses, handles versioning, and provides error responses. Message queue enables asynchronous processing using Redis-based job queue with Celery framework for firmware analysis jobs, network scan requests, and classification tasks with results published to subscribers. Data correlation engine links findings across subsystems correlating by device identifiers including MAC, IP, and firmware hash, joins firmware vulnerabilities with network results, associates malware detections with affected devices, calculates aggregate risk scores, and identifies attack patterns. Alert generator produces timely notifications monitoring for high-severity findings including CVSS $\geq$ 7.0 vulnerabilities and high-confidence malware detections, evaluates against configurable rules, applies suppression preventing duplicates, formats notifications with relevant context, and delivers via multiple channels including email, webhooks, and dashboard. Report generator creates comprehensive assessments aggregating findings from all subsystems, generates executive summaries, produces detailed technical sections, creates visualizations, exports in multiple formats, and supports scheduled and on-demand generation. Web dashboard provides unified interface as modern single-page application with React/Vue.js, real-time WebSocket updates, interactive D3.js visualizations, responsive design, role-based access control, and comprehensive search and filtering.

\section{Advantages of Proposed System}

\subsection{Comprehensive Security Coverage}

Our system addresses threats across multiple IoT stack layers simultaneously. Firmware layer analysis identifies vulnerabilities in device firmware code, misconfigurations, hardcoded credentials and backdoors, insecure cryptographic implementations, and buffer overflows. Network layer discovery provides complete network visibility, port scanning reveals exposed services, traffic analysis detects malicious communications, and topology mapping identifies unusual relationships. Application layer classification identifies known and novel malware threats, behavioral analysis detects suspicious patterns, family classification aids incident response, and real-time detection enables rapid response. Cross-layer correlation reveals complex attack patterns as the integration engine automatically connects findings across layers. Traditional separate tools identify findings independently requiring manual analyst correlation, while our automatic correlation dramatically reduces time-to-detection and response enabling proactive threat mitigation.

\subsection{Automation and Scalability}

FIRMAI design maximizes automation eliminating tedious manual tasks. Manual firmware reverse engineering requires days to weeks per device while our automated emulation processes 50+ images per hour. Manual device inventory in large networks is impractical while our scanner completes Class C subnets in under 5 minutes. Traditional malware analysis requires specialized expertise and significant time per sample while our trained model classifies 1000+ samples per minute with GPU. Automation enables comprehensive assessment rather than small subset sampling, dramatically improving security posture. Parallel processing throughout the system includes Docker containerization enabling concurrent firmware emulation with isolation, multi-threaded network scanning distributing workload, batch malware inference processing multiple samples simultaneously with GPU providing 10--50x speedup, and multiple GPUs for higher throughput. This parallel architecture scales from single-server deployments to distributed clusters handling enterprise-scale workloads.

\subsection{Advanced AI Capabilities}

Our deep learning model automatically learns complex malware patterns. Automatic feature learning uses CNN discovering relevant features through training without manual engineering while multi-layer architecture learns hierarchical representations from low-level packet features to high-level behavioral patterns. Generalization enables detecting novel malware variants exhibiting similar behaviors with transfer learning adapting to new families using limited labeled examples. Adaptation through periodic retraining keeps models current with evolving threats while new families can be added without architectural changes. High accuracy achieves $>$99\% on IoT-23 test set~\cite{stratosphere} with $>$95\% precision and recall per family and low false positive rate $<$1\% reducing alert fatigue. Real-world validation on actual malware samples confirms effectiveness with performance competitive or superior to published research. Confidence scoring provides calibrated probabilities allowing low-confidence predictions flagged for manual review.

\subsection{Cost-Effectiveness}

Open-source foundation provides substantial advantages. Zero licensing costs use freely available components including QEMU, Python, TensorFlow, PostgreSQL, MongoDB, and Docker. No vendor lock-in with complete source code access prevents dependency on single vendor while organizations maintain full control. Community support provides bug fixes and enhancements with extensive documentation reducing learning curves. Commercial platforms cost \rupee 5--20 lakhs annually in licensing plus implementation and support fees which our system eliminates. Commodity hardware runs on standard servers without specialized equipment including consumer-grade workstation (\rupee 1.2 lakhs) for development, standard rackmount servers (\rupee 1.5--7 lakhs) for production, and flexible cloud deployment eliminating upfront expenditure. Preventive savings deliver ROI through breach prevention averaging \rupee 50 lakhs-\rupee 1 crore for SMBs with even one prevented incident justifying investment, early vulnerability detection being 10--100x cheaper than post-deployment patching, and labor efficiency saving 100+ analyst hours monthly worth \rupee 2--5 lakhs annually.

\subsection{Flexibility and Extensibility}

Modular architecture with well-defined interfaces enables extending capabilities including additional scanners for Bluetooth, Zigbee, or custom protocols, alternative ML models like RNN or transformer architectures, organization-specific analysis modules, and custom export formats and visualizations. Configurable workflows allow users customizing system behavior through scanning parameters adjusting port ranges and timeouts, emulation settings configuring resource limits, classification thresholds tuning confidence levels, and alert rules defining custom generation logic. Integration-friendly standard interfaces include REST APIs enabling integration with any HTTP-supporting system, standard formats JSON/CSV/PDF working with existing tools, webhooks pushing notifications to external systems, SIEM integration exporting to Splunk/ELK/QRadar, and SOAR integration triggering automated response playbooks. Educational and research value provides hands-on learning with firmware analysis exposing low-level concepts, network security with packet manipulation experience, machine learning with practical application, and system integration with distributed systems experience. Reproducible research through open source complete code, methodology documentation enabling replication, test data facilitating validation, and performance metrics enabling comparison contributes to broader security ecosystem.

\section{System Components and Integration}

\subsection{Firmware Emulation Implementation}

Firmware extraction implementation uses binwalk as primary tool with FirmwareExtractor class handling extraction running binwalk with signature scanning and extraction, handling squashfs with sasquatch for custom compression, extracting JFFS2 filesystems, identifying architecture by analyzing kernel images, and locating kernels in extraction directory. QEMU emulation orchestration through FirmwareEmulator class dynamically conffigures based on firmware characteristics, selects appropriate pre-compiled kernel matching version and configuration, builds QEMU command line specifying machine type, kernel, rootfs drive, kernel append parameters, network configuration with TAP interfaces, and memory allocation, starts emulation launching QEMU process and monitoring boot for success indicators or failure detection. Arbitration technique implementation uses strategy pattern with ArbitrationStrategy base class and specific strategies including BootArbitration modifying kernel cmdline forcing shell as init, NetworkArbitration forcing interface creation with generated network scripts, and NVRAMArbitration emulating storage creating NVRAM defaults as persistent files. Implementation uses Python with subprocess for process management, file manipulation for filesystem operations, and systematic intervention application when failures occur.

\subsection{Network Scanner Implementation}

ARP scanner implementation uses Scapy for low-level packet control with ARPScanner class performing scans creating ARP request packets for specified CIDR ranges, broadcasting with Ethernet destination ff:ff:ff:ff:ff:ff, sending and receiving with configurable timeout, and parsing responses extracting IP psrc and MAC hwsrc addresses returning results list with IP, MAC, and timestamp. TCP port scanner implementation uses multi-threading for performance with TCPScanner class managing concurrent scans using ThreadPoolExecutor distributing port scanning across threads, scanning individual ports using socket with connect\_ex testing connectivity, collecting open ports for each target, and grabbing banners connecting to open ports receiving initial response data. Device identification implementation with DeviceIdentifier class performs vendor lookup using mac-vendor-lookup querying updated OUI database, handles unknown vendors gracefully, classifies device types analyzing port signatures matching routers by \{80, 443, 22, 23\} ports with vendor keywords, IP cameras by \{554, 8000, 8080\} with camera vendor keywords, IoT hubs by \{1883, 8883, 5683\} MQTT/CoAP ports, and returns device type with confidence score.

\subsection{Malware Classifier Implementation}

Preprocessing pipeline implementation with TrafficPreprocessor class extracts features from PCAP files using rdpcap reading packets and extracting size, protocol, ports, TCP flags, inter-arrival times, aggregating to flow-level statistics, preprocessing feature matrices handling missing values with mean imputation, encoding categorical variables using LabelEncoder, scaling numerical features with StandardScaler, and handling class imbalance using SMOTE oversampling. CNN model implementation uses TensorFlow/Keras with MalwareClassifier class building architecture with Input layer accepting num\_features dimensions, Dense layers with 512/256/128/64 neurons using ReLU activation, BatchNormalization after each Dense layer, Dropout regularization with 0.4/0.4/0.3/0.0 rates, and output Dense layer with softmax activation for num\_classes, compiling with Adam optimizer at 0.001 learning rate and categorical crossentropy loss, training with EarlyStopping callback monitoring val\_loss with patience 10, ModelCheckpoint saving best weights, and TensorBoard logging, performing inference with predict generating probability distributions and argmax selecting highest probability classes with max extracting confidence scores.

\subsection{System Integration Implementation}

REST API implementation uses FastAPI creating unified interface with firmware analysis endpoints for upload accepting UploadFile creating firmware\_id and enqueuing analysis, status checking querying database for firmware\_id status, and results retrieval returning complete analysis findings. Network scanning endpoints initiate scans accepting ScanRequest with CIDR range and type, enqueuing scan job returning scan\_id, and retrieving results querying scan\_results database. Malware classification endpoints classify traffic accepting ClassificationRequest with base64 PCAP data, decoding and extracting features, performing inference, and returning classification with confidence. Integrated endpoints provide dashboard summary aggregating firmware/network/malware statistics with calculated risk scores. Celery task queue implementation uses Redis broker with analyze\_firmware\_task performing extraction using FirmwareExtractor, emulation using FirmwareEmulator, vulnerability scanning using VulnerabilityScanner, storing results in database, and returning status with firmware\_id. scan\_network\_task performs ARP scanning using ARPScanner, TCP scanning using TCPScanner, device identification using DeviceIdentifier, compiling device list with all attributes, storing scan results, and returning status with scan\_id. Docker Compose configuration defines multi-container deployment with postgres service for firmware metadata, mongodb for scan results, redis for caching and queuing, minio for object storage, api service running FastAPI, worker service running Celery, and dashboard service running React/Vue frontend, using volumes for data persistence and environment variables for configuration.